{-# LANGUAGE DataKinds                  #-}
{-# LANGUAGE FlexibleInstances          #-}
{-# LANGUAGE GADTs                      #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE KindSignatures             #-}
{-# LANGUAGE LambdaCase                 #-}
{-# LANGUAGE MultiParamTypeClasses      #-}
{-# LANGUAGE OverloadedStrings          #-}
{-# LANGUAGE RankNTypes                 #-}
{-# LANGUAGE TemplateHaskell            #-}
{- | Contains an embedded domain specific language for generating a
program in the Guarded Common Language represented by "GCL.AST".
-}
module GCL.DSL where

import           Prelude              hiding ((&&), (/=), (<), (<=), (==), (>),
                                       (>=), (||))

import qualified GCL.AST              as AST

import           Control.Applicative
import           Control.Lens
import           Control.Monad
import           Control.Monad.Except
import           Control.Monad.RWS
import           Data.Foldable
import           Data.Map.Strict      (Map)
import qualified Data.Map.Strict      as Map
import           Data.String


-- * Code Generation

-- | Scope information about a declared variable.
data VarInfo = VarInfo
  { _varType          :: AST.Type
  -- ^ The type of the variable as given in the declaration.
  , _varQualifiedName :: AST.QVar
  -- ^ The fully qualified name of the variable, unqiue in the program.
  }
makeLenses ''VarInfo

-- | Environment with information needed during code generation.
data CodeGenEnv = CodeGenEnv
  { _declarations    :: Map AST.UVar VarInfo
  , _qualifiedPrefix :: [AST.Name]
  }
makeLenses ''CodeGenEnv

data CodeGenState = CodeGenState
  { _nextUnique :: Int
  }
makeLenses ''CodeGenState

-- | Output of code generation.
type CodeBlock = [AST.Statement]

-- | Errors occuring during code generation.
type GclError = String

-- | The code generation monad.
newtype Code a = Code { runCode' :: RWST CodeGenEnv CodeBlock CodeGenState (Except GclError) a }
  deriving (Functor, Applicative, Monad, MonadReader CodeGenEnv, MonadWriter CodeBlock, MonadState CodeGenState, MonadError GclError)

runCode :: Code a -> CodeGenEnv -> CodeGenState -> Either GclError (a, CodeGenState, CodeBlock)
runCode code e s = runExcept (runRWST (runCode' code) e s)

evalCode :: Code a -> CodeGenEnv -> CodeGenState -> Either GclError (a, CodeBlock)
evalCode code e s = runExcept (evalRWST (runCode' code) e s)

execCode :: Code a -> CodeGenEnv -> CodeGenState -> Either GclError (CodeGenState, CodeBlock)
execCode code e s = runExcept (execRWST (runCode' code) e s)

-- * Primitives

-- | Emits a single statement.
emit :: AST.Statement -> Code ()
emit stmt = tell [stmt]

-- | @extractCode m@ returns the code generated by @m@ without adding it to the current output.
extractCode :: Code () -> Code CodeBlock
extractCode gen = snd <$> censor (const mempty) (listen gen)

-- | Wraps the result of 'extractCode' in a 'AST.Block' statement.
extractStmt :: Code () -> Code AST.Statement
extractStmt = fmap AST.Block . extractCode

-- | Declares a program.
program :: AST.Name -> [AST.Decl AST.UVar] -> [AST.Decl AST.UVar] -> Code () -> Either GclError AST.Program
program name inputVars outputVars code = fst <$> evalCode ast initEnv initState where
  ast = declare inputVars $ \qinput ->
      declare outputVars $ \qoutput ->
        AST.Program name qinput qoutput <$> extractStmt code

  initEnv = CodeGenEnv
    { _declarations    = Map.empty
    , _qualifiedPrefix = [name]
    }

  initState = CodeGenState { _nextUnique = 0  }

-- | Returns a unique number.
unique :: Code Int
unique = nextUnique <<+= 1

-- | Creates a new qualified name.
mkQualifiedVar :: AST.UVar -> AST.Type -> Code AST.QVar
mkQualifiedVar (AST.UVar name) ty = do
  id <- unique
  pr <- view qualifiedPrefix
  return $ AST.QVar (pr ++ [name]) id ty

-- | Increases the nesting level for qualified names.
nested :: [AST.Name] -> Code a -> Code a
nested prefix = local (qualifiedPrefix %~ (++ prefix))

-- | Declares new variables.
declare :: [AST.Decl AST.UVar] -> ([AST.Decl AST.QVar] -> Code a) -> Code a
declare udecls body = do
  let newDecl (AST.Decl uv ty) (scope, decls)
        | Map.member uv scope = throwError "duplicate declaration in var"
        | otherwise           = do
            qv <- mkQualifiedVar uv ty
            return $ (Map.insert uv (VarInfo ty qv) scope, AST.Decl qv ty : decls)
  (newScope, qdecls) <- foldrM newDecl (Map.empty, []) udecls
  local (declarations %~ Map.union newScope) (body qdecls)

-- * Type DSL

int :: AST.Type
int = AST.IntType

boolean :: AST.Type
boolean = AST.BoolType

array :: AST.Type -> AST.Type
array = AST.ArrayType

-- * Declaration DSL

-- | Syntactic sugar for declarations.
-- Example: @"foo" `as` array int@
as :: AST.UVar -> AST.Type -> AST.Decl AST.UVar
as = AST.Decl

-- * Expression DSL

-- | Searches for the qualified name of an unqualified reference in the current scope.
lookupVar :: AST.UVar -> Code AST.QVar
lookupVar uv@(AST.UVar name) = views declarations (Map.lookup uv) >>= \case
  Nothing -> throwError $ "variable '" ++ name ++ "' not declared"
  Just vi -> return $ view varQualifiedName vi

-- | An integer literal.
litI :: Int -> Code AST.Expression
litI = return . AST.IntLit

-- | A boolean literal.
litB :: Bool -> Code AST.Expression
litB = return . AST.BoolLit

-- | A boolean true literal.
true :: Code AST.Expression
true = litB True

-- | A boolean false literal.
false :: Code AST.Expression
false = litB False

-- | Creates a qualified reference from an unqualified name.
ref  :: AST.UVar -> Code AST.Expression
ref uv = AST.Ref <$> lookupVar uv

-- | Applies a binary boolean operator.
boolOp :: AST.BoolOp -> Code AST.Expression -> Code AST.Expression -> Code AST.Expression
boolOp bo = liftM2 (AST.BoolOp bo)

-- | Applies a binary integer operator.
intOp  :: AST.IntOp -> Code AST.Expression -> Code AST.Expression -> Code AST.Expression
intOp io = liftM2 (AST.IntOp io)

-- | Applies a binary relational operator.
relOp  :: AST.RelOp -> Code AST.Expression -> Code AST.Expression -> Code AST.Expression
relOp ro = liftM2 (AST.RelOp ro)

-- | Creates an array-indexing expression.
arrIndex :: Code AST.Expression -> Code AST.Expression -> Code AST.Expression
arrIndex = liftM2 AST.Index

-- | Creates an array replacement expression.
repBy :: Code AST.Expression -> Code AST.Expression -> Code AST.Expression -> Code AST.Expression
repBy arr idx expr = liftM3 AST.RepBy arr idx expr

-- | Creates a boolean negation.
neg :: Code AST.Expression -> Code AST.Expression
neg = liftM AST.NegExp

-- | Creates a forall quantifier.
forall :: AST.Decl AST.UVar -> Code AST.Expression -> Code AST.Expression
forall udecl quantExp = declare [udecl] $ \[qdecl] -> liftM (AST.ForAll qdecl) quantExp

exists :: AST.Decl AST.UVar -> Code AST.Expression -> Code AST.Expression
exists udecl quantExp = neg $ forall udecl (neg quantExp)

-- | The array index operator.
infixl 9 !
(!) :: Code AST.Expression -> Code AST.Expression -> Code AST.Expression
(!) = arrIndex

infixr 3 /\
(/\) :: Code AST.Expression -> Code AST.Expression -> Code AST.Expression
(/\) = boolOp AST.OpAnd

infixr 2 \/
(\/) :: Code AST.Expression -> Code AST.Expression -> Code AST.Expression
(\/) = boolOp AST.OpOr

infixr 3 ∧
(∧) :: Code AST.Expression -> Code AST.Expression -> Code AST.Expression
(∧) = (/\)

infixr 2 ∨
(∨) :: Code AST.Expression -> Code AST.Expression -> Code AST.Expression
(∨) = (\/)

infixr 3 &&
(&&) :: Code AST.Expression -> Code AST.Expression -> Code AST.Expression
(&&) = (/\)

infixr 2 ||
(||) :: Code AST.Expression -> Code AST.Expression -> Code AST.Expression
(||) = (\/)

infixr 1 ==>
(==>) :: Code AST.Expression -> Code AST.Expression -> Code AST.Expression
(==>) = boolOp AST.OpImplies

infix 4 <=
(<=) :: Code AST.Expression -> Code AST.Expression -> Code AST.Expression
(<=) = relOp AST.OpLEQ

infix 4 >=
(>=) :: Code AST.Expression -> Code AST.Expression -> Code AST.Expression
(>=) = relOp AST.OpGEQ

infix 4 >
(>) :: Code AST.Expression -> Code AST.Expression -> Code AST.Expression
(>) = relOp AST.OpGT

infix 4 <
(<) :: Code AST.Expression -> Code AST.Expression -> Code AST.Expression
(<) = relOp AST.OpLT

infix 4 ==
(==) :: Code AST.Expression -> Code AST.Expression -> Code AST.Expression
(==) = relOp AST.OpEQ

infix 4 /=
(/=) :: Code AST.Expression -> Code AST.Expression -> Code AST.Expression
(/=) x y = neg (x == y)

-- | Allows the usage of strings directly as references in our AST.
instance IsString (Code AST.Expression) where
  fromString = ref . fromString

-- | Allows the usage of the DSL AST in arithmetic expressions.
instance Num (Code AST.Expression) where
  (+) = intOp AST.OpPlus
  (-) = intOp AST.OpMinus
  (*) = intOp AST.OpTimes
  fromInteger = litI . fromInteger

-- * Statement DSL

skip :: Code ()
skip = emit $ AST.Skip

assert :: Code AST.Expression -> Code ()
assert e = e >>= emit . AST.Assert

assume :: Code AST.Expression -> Code ()
assume e = e >>= emit . AST.Assume

ndet :: Code () -> Code () -> Code ()
ndet left right = do
  leftAst <- extractStmt left
  rightAst <- extractStmt right
  emit $ AST.NDet leftAst rightAst

while :: Code AST.Expression -> Code AST.Expression -> Code () -> Code ()
while invariant guard body = do
  inv <- invariant
  cnd <- guard
  bodyStmt <- extractStmt body
  emit $ AST.While inv cnd bodyStmt

infix 0 $$=
($$=) :: [Code AST.Expression] -> [Code AST.Expression] -> Code ()
($$=) lvals rvals = transformAll lvals rvals >>= emit . AST.Assign where
  transformAll [] []           = return []
  transformAll (vm:vs) (em:es) = do
      v <- vm
      e <- em
      (:) <$> transform v e <*> transformAll vs es
  transformAll _ _             = throwError "non-matching number of values in multi-assignment"

  transform (AST.Ref v)     expr = return (v, expr)
  transform (AST.Index a i) expr = transform a (AST.RepBy a i expr)
  transform _               _    = throwError "expression is not an lvalue"

infix 0 $=
($=) :: Code AST.Expression -> Code AST.Expression -> Code ()
($=) lval rval = [lval] $$= [rval]

var :: [AST.Decl AST.UVar] -> Code () -> Code ()
var udecls body = declare udecls $ \qdecls -> do
  bodyStmt <- extractStmt body
  emit $ AST.Var qdecls bodyStmt

if_ :: Code AST.Expression -> Code () -> Code () -> Code ()
if_ cond then_ else_ = ndet (assume cond >> then_) (assume (neg cond) >> else_)
