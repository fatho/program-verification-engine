\documentclass[]{scrartcl}

\usepackage{amsmath}
\usepackage{bussproofs}
\usepackage{color}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{url}

\EnableBpAbbreviations

\newcommand{\WHILE}[2]{\ensuremath{\mathbf{while}\;#1\;\mathbf{do}\;\{#2\}}}
\newcommand{\IF}[3]{\ensuremath{\mathbf{if}\;#1\;\mathbf{then}\;\{#2\}\;\mathbf{else}\;\{#3\}}}
\newcommand{\SKIP}{\ensuremath{\mathbf{skip};}}
\newcommand{\ASSUME}[1]{\ensuremath{\mathbf{assume}\;#1;}}
\newcommand{\ASSERT}[1]{\ensuremath{\mathbf{assert}\;#1;}}
\newcommand{\WLP}[2]{\ensuremath{\mathbf{wlp}\;#1\;#2}}
\newcommand{\UNROLLSQ}[3]{\ensuremath{[\mathit{while}]^{#1}(#2, #3)}}
\newcommand{\UNROLLDI}[3]{\ensuremath{\langle\mathit{while}\rangle^{#1}(#2, #3)}}

%opening
\title{A Program Verification Engine for Imperative Languages}
\subtitle{Course: Program Verification}
\author{Giovanni Garufi, Fabian Thorand}
\date{\today}

\newcommand{\blue}[1]{\textcolor{blue}{#1}}

\newcommand{\HT}[3]{\blue{\{#1\}} #2 \blue{\{#3\}}}

\begin{document}

\maketitle

\tableofcontents

%==================================================================================================
\section{Introduction}
%==================================================================================================

In this report we present our tool for formally verifying programs written in
imperative languages. While testing already significantly decreases the chances
of having bugs in a program, it is often hard or event impossible to write test
cases that cover every execution path.

One way of making sure a program works as intended is to formally prove that its
behavior adheres to the specification.
Such a specification usually consists of a pre- and a post-condition.
The intention is, that the results of a program satisfy the post-condition,
given that the inputs to the program fulfil the pre-condition.
The Hoare calculus provides one mathematical foundation for conducting such
proofs based on pre- and post-conditions.
But of course, doing proofs by hand is error-prone and tedious even for
simple programs.

Ideally, there would be a tool automatically proving properties about programs.
Unfortunately, it is -- in general -- undecidable to check whether a given
program (represented as a Turing machine) satisfies a given property, due to the
Halting problem\footnote{as shown by Rice's theorem}.
The power of turing machines is usually introduced in programming languages
by some form of loops or general recursion.

Fortunately, this can be migitated by requiring the programmer to annotate loops
with invariants, guiding the verification tool in the right direction.
For some specific cases it might even be possible to automatically infer those
invariants.

Using a technique called \emph{Predicate Transformers} it is possible to infer
the precondition required for a program to satisfy its post-condition.

Upon that technique we built our verification engine that we describe in the
following sections.

%==================================================================================================
\section{Project Structure}
%==================================================================================================

We implemented our project in the Haskell programming language making use of
Monads to achieve abstraction.
For invoking the solver we rely on the \texttt{sbv}\footnote{\url{https://hackage.haskell.org/package/sbv}}
library available on Hackage.
It provides a common interface to several solver backends via the SMT-LIB v2 standard,
although some features are only implemented in some solvers.
For that reason, we only use the Microsoft Z3 backend for now.

SBV provides a typed and untyped (w.r.t. expressions) interface to the prover.
As our internal AST representation is untyped and we rely on the type correctness of
the user-provided programs anyway, we use the untyped API.

Our core implementation is devided in four parts, the AST, the monadic DSL, the WLP transformer
and the adapter to the prover backend. 
Furthermore, we have implemented a test suite asserting the expected results for the examples
in the project assignment description.

On top of the basic requirements, we also support array assignments, invariant inference and
program calls. The following sections describe our implementation in greater detail.

\section{Monadic DSL for the Guarded Common Language} 

Our abstract syntax tree representing programs consists of three levels.
The root node stores the name of the program, the input and output arguments and a body statement.
The statement and expression trees closely follow the grammar outlined in the assignment description,
with one notable difference. Instead of sequencing statements pairwisely, we have an explicit \emph{block}
statement wrapping a list of statements.
Our expression AST is untyped, therefore we require the user to only construct type correct programs.
We have an unqualified and a qualified representation of variables. 

The DSL makes uses of the unqualified names (identifiers as they are supplied by the user) and performs
name resolution. The AST produced by the DSL then uses the qualified names, which contain a namespace 
(currently only the program name) and a unique number besides the unqualified name.

In order to facilitate writing programs in the DSL we allow Haskell string literals to be directly
used as variables by means of the \emph{OverloadedStrings} GHC extension and make it possible to
directly use integer literals and common mathematical operations by instantiating the \emph{Num} type class. 

% TODO: maybe listing of the AST types

% describe our monadic DSL (and also the resulting AST)

\section{Implementing Predicate Transformer}
% TODO: describe general implementation architecture

\subsection{Basic Statements}
% TODO: not much to say I think, pretty straight forward

\subsection{Loops}
% TODO: describe handling/checking of invariants, code excerpt here

\subsection{Arrays}
% TODO: refer to array theory of Z3

\subsection{Program Calls}
% TODO: describe environment lookup and inlining 

%==================================================================================================
\section{Invariant Inference}
%==================================================================================================

In the case where the user has not annotated the invariant of while-loops, 
it might still be possible to infer the invariant using fixpoint-iteration
or finite unrolling.

\subsection{Fixpoint Iteration}

When we have a loop \lstinline|while g do S;|, it is equivalent to 
\begin{lstlisting}
if g then { S; while g do S; }
     else skip;
\end{lstlisting}
effectively unrolling the loop once.

If $W$ is \textbf{wlp} of that loop, we have $W = \WLP{(\WHILE{g}{S})}{Q}$ as well as 
$W = (g \land \WLP{S}{(\WLP{(\WHILE{g}{S})}{Q})}) \lor (\neg g \land Q)$ according to the unrolling above.
Therefore, we can conclude that $W = (g \land \WLP{S}{W}) \lor (\neg g \land Q)$.

We can find the greatest fixpoint of this equation by iterating, starting from the weakest invariant \emph{true},
following from the \emph{Knaster-Tarski} fixpoint-theorem.
\begin{align}
  \label{eq:fp:base} W_0 &= \mathit{true} \\
  \label{eq:fp:iter} W_{i+1} &= (g \land W_i) \lor (\neg g \land Q) 
\end{align} 

If a fixpoint exists, there is an $i$ for which $W_{i+1} = W_i$ holds. 
We implemented the iteration according to equations \ref{eq:fp:base} and \ref{eq:fp:iter}.
After each iteration, we invoke the backend-prover to check whether $W_{i+1} \iff W_i$ holds.
In that case we have found the fixpoint $W_i$ and return it to the \textbf{wlp} function as
invariant.
We additionally implemented an optional limit to the number of iterations.
If that limit is exceeded without finding an invariant, we return a precondition that requires
that the loop will never be executed and the post-condition already holds. 

% TODO: anything else about fixpoints?

\subsection{Loop Unrolling}

As an alternative to fixpoint-iteration we can also unroll a loop a finite number of times and
compute the \textbf{wlp} of the unrolling. The last iteration then either asserts that the
loop guard will not hold, or just assume that it doesn't hold anymore. 
Formally, those unrollings, named  are defined as follows.
\begin{align}
\UNROLLSQ{0\phantom{+1}}{g}{S} &= \ASSERT{\neg g} \\
\UNROLLSQ{k+1}{g}{S} &= \IF{g}{S; \UNROLLSQ{k}{g}{S}}{\SKIP}
\end{align}

\begin{align}
\UNROLLDI{0\phantom{+1}}{g}{S} &= \ASSUME{\neg g} \\
\UNROLLDI{k+1}{g}{S} &= \IF{g}{S; \UNROLLDI{k}{g}{S}}{\SKIP}
\end{align}

Our implementation first computes (lazily) the unrolled loop and then applies
the \textbf{wlp} transformer to the unrolling. 

% TODO: anything else about loop unrolling?

%==================================================================================================
\section{Solver Backend}
%==================================================================================================

% TODO: general interoduction to the backend

\subsection{Free Monad Interface}

% TODO: describe free monad

\subsection{Handling Quantifiers}

Our GCL DSL allows arbitrary nesting of universal and existential quantification,
but the solver library we use requires all quantified variables to be defined in
the beginning.
Fortunately, for every formula in classical logic there is an equivalent formula
in prenex normal form, where all quantifiers occur in the beginning.
The conversion to prenex normal form requires that every quantified variable is
unique to avoid accidental capturing when pulling the quantifiers outside.
Additionally, all negations have to be pushed inwards, swapping universal and
existential quantification on the go.
Skolemization is then perfomed by the prover backend.
An additional benefit from the conversion to prenex normal form is, that it allows
us to return a model for all existential quantifications in a SAT proof, as only 
the values of the outermost existentials are returned by the library.

% TODO: describe remaining conversion to SBV (straightforward)

%==================================================================================================
\section{Conclusion}
%==================================================================================================

Using Haskell allowed us to write the WLP implementation in a succinct declarative
style, closely following the underlying formal definitions.

% TODO: other conlusions

\end{document}
